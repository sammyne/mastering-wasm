# 09. 函数调用（下）

## 本地函数调用
- wasm 模块内部可调用函数类型
  - 导入的**外部函数**
    - 普通函数（表现为 wasm 字节码）
    - 本地函数（使用本地语言实现）
  - 模块内部定义的**内部函数**
- 为了便于描述，将（外部导入/模块定义的）代码为 wasm 字节码的函数简称为 wasm 函数

### 本地函数介绍
- 好处
  - 拓展语言能力
  - 重用本地语言编写的已有代码
- 本地语言可调用 wasm 函数也有重要作用：例如基于 wasm 的插件系统
- 3 种调用本地函数的实现方式
    ```wat
    ;; 样例加法函数
    (module
      (import "env" "add_i32"
        (func $add_i32 (param i32 i32) (result i32))
      )
    )
    ```
  - 本地函数签名完全映射 wasm 函数签名：本地函数的参数数量和类型以及返回值的数量和类型与 wasm 函数完全一致
    ```wat
    func addI32(a, b int32) int32 { return a + b }
    ```
  - 使用操作数栈传递参数和返回值：虚拟机把操作数栈通过某种方式暴露给本地函数
    ```go
    type GoFunc = func(WasmVM)
    type WasmVM interface {
      PushI32(int32)
      PopI32() int32
      ...
    }

    func addI32(vm WasmVM) {
      b, a := vm.PopI32(), vm.PopI32()
      vm.PushI32(a + b)
    }
    ```
  - 通过切片传递参数和返回值
    ```go
    type WasmVal = interface{}
    type GoFunc = func(args []WasmVal) []WasmVal

    func addI32(args []WasmVal) []WasmVal {
      a := args[0].(int32)
      b := args[1].(int32)
      return []WasmVal{a + b}
    }
    ```
    - 优点
      - 统一本地函数签名
      - 没有过多 wasm 内部细节（操作数栈和函数调用规则）暴露给本地函数
      - 实现复杂度中等，本地函数编写相对容易
    - 本地函数需要知道 wasm 和本地语言的基本类型映射关系
- wasm 函数和本地函数的异同之处
  - 相同点
    - 是可被调用的函数
    - （按照函数签名）从栈顶拿走参数并放回返回值
  -  不同点
    - wasm 函数在模块内部用字节码定义
    - 本地函数外部导入，本地语言编写
- 链接本地函数编程实现注意事项
  - 外部函数和内部函数共享索引空间，外部函数在前，内部函数在后

## 间接函数调用
- 直接函数调用
  - 具体函数在编译器确定，函数索引硬编码在 `call` 指令的立即数
  - 别名“静态调用”
- 间接函数调用
  - 编译器只能确定被调函数类型（`call_indirect` 指令的立即数是被调函数的类型索引）
  - 具体调用函数在运行期间根据栈顶操作数确定
  - 别名“动态调用”
- 样例代码参见 [calc.wat](./code/calc.wat)
  - 模块初始化后，表放置了 3 个函数引用（由内联的元素域指定）
  - 假设现在执行到 `calc()` 函数的 `call_indirect` 指令，虚拟机状态如下
    ```
    +------+           +----------+           +------------+
    |      |           | #0  $add |           | #0  calc() |
    |      |           +----------+           +------------+
    +------+    +----->+ #1  $sub +-----+     | #1  add()  |
    |  op  +----+      +----------+     |     +------------+
    +------+           | #2  $mul |     +---->+ #2  sub()  |
    |  b   |           +----------+           +------------+
    +------+           |          |           | #3  mul()  |
    |  a   |           |          |           +------------+
    +------+           |          |           |            |
    |  ... |           |          |           |            |
    +------+           +----------+           +------------+
      stack               table                   funcs
    ```
  - 指令执行时，从栈顶弹出一个 `i32` 类型的操作数（假设为 1），以此为索引查表找到函数引用调用即可

### 间接函数调用介绍
### 实现表
- wasm 表存放的是元素，且目前唯一支持的元素类型为**函数引用**
- 直接用函数索引不能作为函数引用的原因：表内函数引用指向的函数可能并不在该模块的函数集合（外部导入的函数+内部定义的函数）？

### call_indirect 指令
- `call_indirect` 指令从栈顶弹出一个 `i32` 类型的操作数，查表找到函数引用，然后调用函数

```
  ...][call_indirect][type_idx][0][...

+-----------+        +------------------------+
|           |        |                        |
|           |        |                        |
|           |        |                        |
+-----------+        |                        |
|  op(i32)  |        |                        |
+-----------+        |                        |
|  b(i64)   |        |                        |
+-----------+        +------------------------+
|  a(i64)   |        | r(i64)=table[op](a, b) |
+-----------+        +------------------------+
|    ...    |        |         ...            |
+-----------+        +------------------------+
```
