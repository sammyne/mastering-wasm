# 02. 二进制格式

## 二进制格式介绍
### 总体结构

```
+-----------------------+
| +-------+ +---------+ |
| | Magic | | Version | |
| +-------+ +---------+ |
| +-------------------+ |
| | TypeSec           | |
| +-------------------+ |
| +-------------------+ |
| | ImportSec         | |
| +-------------------+ |
| +-------------------+ |
| | FuncSec           | |
| +-------------------+ |
| +-------------------+ |
| | TableSec          | |
| +-------------------+ |
| +-------------------+ |
| | MemSec            | |
| +-------------------+ |
| +-------------------+ |
| | GlobalSec         | |
| +-------------------+ |
| +-------------------+ |
| | ExportSec         | |
| +-------------------+ |
| +-------------------+ |
| | StartSec          | |
| +-------------------+ |
| +-------------------+ |
| | ElemSec           | |
| +-------------------+ |
| +-------------------+ |
| | CodeSec           | |
| +-------------------+ |
| +-------------------+ |
| | DataSec           | |
| +-------------------+ |
+-----------------------+
```

Wasm 规范一共定义 12 种段，分别赋予不同 ID（从 0 到 11）。除自定义段以外，其他段最多只能出现依次，且必须按照段 ID 递增的顺序出现。

#### 1. 类型段 TypeSec

- ID 为 1
- 该段列举 Wasm 模块的所有 **函数类型**（又称函数签名、函数原型）

> 由于导入段、函数段、代码段等都需要知道函数类型信息，所以类型段需要出现在这 3 段之前。

#### 2. 导入段 ImportSec 和导出段 ExportSec

- ID 分别为 2 和 7
- 两个段分别列出模块的所有导入项和导出项
- 多个模块可以通过导入和导出项链接在一起

> - 由于导入的函数、表、内存和全局变量在各自索引空间的最前面，所以导入段必须在这 4 段之前。
> - 由于导出函数、表、内存和全局变量时需要知道其索引，所以导出段必须在这 4 段之后。

#### 3. 函数段 FuncSec 和代码段 CodeSec

- ID 分别为 3 和 10
- 内部函数信息被分开存储在两个段
  - 函数段实际上是一个索引表，列出内部函数所对应的签名索引
  - 代码段存储内部函数的局部变量信息和字节码
- 函数段和代码段的项目数量必须一致，且一一对应。

#### 4. 表段 TableSec 和元素段 ElemSec

- ID 分别为 4 和 9
- 表段列举模块内定义的所有表
- 元素段列举表初始化数据

> Wasm 规范规定模块最多只能导入或定义一张表，所以即使模块有表段，里面也只能有一个项目。

#### 5. 内存段 MemSec 和数据段 DataSec

- ID 分别为 5 和 11。
- 内存段列举模块内定义的所有内存
- 数据段列举内存初始化数据

> Wasm 规范规定模块最多只能导入或定义一块内存，所以即使模块有内存段，里面也只能有一个项目。


#### 6. 全局段 GlobalSec

- ID 为 6
- 该段列举模块定义的所有全局变量，包括值类型、可变性和初始值

#### 7. 起始段 StartSec

- ID 为 8。该段给出模块**唯一**的起始函数索引。
- 起始函数有两个作用如下
  - 模块加载后进行一些初始化工作
  - 把模块变成可执行程序

#### 8. 自定义段

- ID 为 0
- 该段服务于编译器，用于存放函数名等调试信息或其他附加信息
- 自定义段不参与 Wasm 语义，所以即便完全忽略也不影响模块的执行

### 索引空间
Wasm 的函数签名、函数、表、内存、全局变量、局部变量和跳转标签等均需要索引。

### 实体类型

类型 | 说明
----:|:-----
值 | `i32`、`i64`、`f32` 和 `f64` 分别表示 32 位整数、64 位整数、32 位浮点数和 64 位浮点数。Wasm 底层的整数类型不区分符号
函数 | 函数签名或原型，描述函数的参数数量和类型，以及返回值数量和类型
限制 | 描述表的元素数量或内存页数的上下限
内存 | 描述内存的页数限制
表 | 描述表的元素类型以及元素数量的限制。目前 Wasm 规范只定义了一种元素类型，即函数引用
全局变量 | 描述全局变量的类型以及可变性
结果 | 表示函数或表达式的执行结果
外部 | 函数类型、表类型、内存类型和全局变量类型的集合

## 二进制格式分析

本节借助 xxd 和 WABT 提供的 wasm-objdump 工具分析 Wasm 二进制格式，相应的二进制文件为 [hello-world.wasm](./code/hello-world.wasm)。

### 魔数和版本号

- 魔数占 4 字节，内容固定为 `\0asm`
- 版本号占 4 字节，当前版本为 1

```bash
xxd -u -g 1 hello-world.wasm

00000000: 00 61 73 6D 01 00 00 00 01 08 02 60 01 7F 00 60  .asm.......`...`
          -----------------------
00000010: 00 00 02 12 01 03 65 6E 76 0A 70 72 69 6E 74 5F  ......env.print_
00000020: 63 68 61 72 00 00 03 02 01 01 04 05 01 70 01 01  char.........p..
...
```

> Wasm 二进制的数值采用小端编码，所以魔数和版本号都倒着排。

### 类型段

- Wasm 二进制的每个段都以 1 字节的段 ID 开始
- 段的统一编码格式如下
  ```
  sec: id|byte_count|byte+   # byte_count 有助于跳过某些段
  byte_count: u32            # LEB128 编码的 32 位无符号整数
  ```
- 大部分段可以包含多个项目，以**向量**结构编码，用 `vec<T>` 表示。采用这种写法，段编码格式可简写为 `id|vec<byte>`，**后续部分会多次沿用这种简写格式**。
- 类型段的编码格式
  ```
  type_sec:  0x01|byte_count|vec<func_type>
  func_type: 0x60|vec<val_type>|vec<val_type> # 第一个 vec 表示参数列表，第二个 vec 表示结果列表
  ```
- 借助 xdd 可看到如下部分输出
  ```bash
  xxd -u -g 1 hello-world.wasm

  00000000: 00 61 73 6D 01 00 00 00 01 08 02 60 01 7F 00 60  .asm.......`...`
                                    -----------------------
  00000010: 00 00 02 12 01 03 65 6E 76 0A 70 72 69 6E 74 5F  ......env.print_
            -----
  00000020: 63 68 61 72 00 00 03 02 01 01 04 05 01 70 01 01  char.........p..
  ...
  ```
- 借助 wasm-objdump 工具可看到如下部分解码结果

  ```bash
  wasm-objdump -x hello-world.wasm 

  ...

  Type[2]:
  - type[0] (i32) -> nil
  - type[1] () -> nil
  ...
  ```

### 导入段
- 模块可以导出 4 种类型成员：函数、表、内存和全局变量，也可以从其他模块导入这 4 种成员
- 借助导入和导出串联多个模块，完成复杂功能
- 导入段的每项需要给出以下信息
  - 模块名
  - 成员名
  - 具体描述信息
- 导入段的编码格式如下
  ```
  import_sec: 0x02|byte_count|vec<import>
  # module_name 和 member_name 可以是任意 UTF-8 编码的字符串，以 vec<byte> 形式存储
  import:     module_name|member_name|import_desc
  import_desc: tag|[type_idx, table_type, mem_type, global_type]
  ```
- 借助 xdd 可看到如下部分输出
  ```bash
  xxd -u -g 1 hello-world.wasm

  00000000: 00 61 73 6D 01 00 00 00 01 08 02 60 01 7F 00 60  .asm.......`...`
  00000010: 00 00 02 12 01 03 65 6E 76 0A 70 72 69 6E 74 5F  ......env.print_
                  -----------------------------------------
  00000020: 63 68 61 72 00 00 03 02 01 01 04 05 01 70 01 01  char.........p..
            -----------------
  ...
  ```
- 借助 wasm-objdump 工具可看到如下部分解码结果
  ```bash
  wasm-objdump -x hello-world.wasm 

  ...
  Import[1]:
  - func[0] sig=0 <print_char> <- env.print_char
  ...
  ```

### 函数段
- 编码格式
  ```
  func_sec: 0x03|byte_count|vec<type_idx>
  ```
- 借助 xdd 可看到如下部分输出
  ```bash
  xxd -u -g 1 hello-world.wasm

  ...
  00000020: 63 68 61 72 00 00 03 02 01 01 04 05 01 70 01 01  char.........p..
                              -----------
  00000030: 01 05 03 01 00 10 06 19 03 7F 01 41 80 80 C0 00  ...........A....
  ...
  ```
- 借助 wasm-objdump 工具可看到如下部分解码结果
  ```bash
  wasm-objdump -x hello-world.wasm

  Function[1]:
  - func[1] sig=1 <main>
  ```

### 表段
- Wasm 规范目前规定模块最多只能定义一张表，且元素类型必须为函数引用（编码为 0x70）
- 除了元素类型，表还需要指定元素数量的限制，包括必须的下限和可选的上限
- 编码格式如下
  ```
  table_sec: 0x04|byte_count|vec<table_type> # 目前 vec 长度必须为 1
  table_type: 0x70|limits
      limits: tag|min|max?
  ```
- 借助 xdd 可看到如下部分输出
  ```bash
  xxd -u -g 1 hello-world.wasm

  ...
  00000020: 63 68 61 72 00 00 03 02 01 01 04 05 01 70 01 01  char.........p..
                                          -----------------
  00000030: 01 05 03 01 00 10 06 19 03 7F 01 41 80 80 C0 00  ...........A....
            --
  00000040: 0B 7F 00 41 80 80 C0 00 0B 7F 00 41 80 80 C0 00  ...A.......A....
  ...
  ```
- 借助 wasm-objdump 工具可看到如下部分解码结果
  ```bash
  wasm-objdump -x hello-world.wasm

  Table[1]:
  - table[0] type=funcref initial=1 max=1
  ```

### 内存段
- Wasm 规范规定模块最多只能定义一块内存
- 内存只需指定内存页数限制
- 编码格式如下
  ```
   mem_sec:  0x50|byte_count|vec<mem_type> # 目前 vec 长度只能是 1
  mem_type: limits
    limits: tag|min|max?
  ```
- 借助 xdd 可看到如下部分输出
  ```bash
  xxd -u -g 1 hello-world.wasm

  00000020: 63 68 61 72 00 00 03 02 01 01 04 05 01 70 01 01  char.........p..
  00000030: 01 05 03 01 00 10 06 19 03 7F 01 41 80 80 C0 00  ...........A....
              --------------
  ...
  ```
- 借助 wasm-objdump 工具可看到如下部分解码结果
  ```bash
  wasm-objdump -x hello-world.wasm

  ...
  Memory[1]:
  - memory[0] pages: initial=16
  ...
  ```

### 全局段
- 编码格式如下
  ```
  global_sec: 0x06|byte_count|vec<global>
      global: global_type|init_expr
  global_type: val_type|mut
        expr: byte*|0x0B
  ```
- 借助 xdd 可看到如下部分输出
  ```bash
  xxd -u -g 1 hello-world.wasm

  ...
  00000030: 01 05 03 01 00 10 06 19 03 7F 01 41 80 80 C0 00  ...........A....
                              -----------------------------
  00000040: 0B 7F 00 41 80 80 C0 00 0B 7F 00 41 80 80 C0 00  ...A.......A....
            -----------------------------------------------
  00000050: 0B 07 2C 04 06 6D 65 6D 6F 72 79 02 00 04 6D 61  ..,..memory...ma
            --
  ...
  ```
- 借助 wasm-objdump 工具可看到如下部分解码结果
  ```bash
  wasm-objdump -x hello-world.wasm

  ...
  Global[3]:
  - global[0] i32 mutable=1 - init i32=1048576
  - global[1] i32 mutable=0 <__data_end> - init i32=1048576
  - global[2] i32 mutable=0 <__heap_base> - init i32=1048576
  ...
  ```

  > 3 个全局变量都是 rust 编译器自动生成的。

### 导出段
- 导出段列举模块的所有导出成员，只有被导出的成员才能被外界访问
- 编码格式如下
  ```
  export_sec: 0x07|byte_count|vec<export>
      export: name|export_desc
  export_desc: tag|[func_idx, table_idx, mem_idx, global_idx]
  ```
- 借助 xdd 可看到如下部分输出
  ```bash
  xxd -u -g 1 hello-world.wasm

  ...
  00000050: 0B 07 2C 04 06 6D 65 6D 6F 72 79 02 00 04 6D 61  ..,..memory...ma
              --------------------------------------------
  00000060: 69 6E 00 01 0A 5F 5F 64 61 74 61 5F 65 6E 64 03  in...__data_end.
            -----------------------------------------------
  00000070: 01 0B 5F 5F 68 65 61 70 5F 62 61 73 65 03 02 0A  ..__heap_base...
            --------------------------------------------
  00000080: 7E 01 7C 00 41 C8 00 10 80 80 80 80 00 41 E5 00  ~.|.A........A..
  00000090: 10 80 80 80 80 00 41 EC 00 10 80 80 80 80 00 41  ......A........A
  ...
  ```
- 借助 wasm-objdump 工具可看到如下部分解码结果
  ```bash
  wasm-objdump -x hello-world.wasm

  ...
  Export[4]:
  - memory[0] -> "memory"
  - func[1] <main> -> "main"
  - global[1] -> "__data_end"
  - global[2] -> "__heap_base"
  ...
  ```

### 起始段
- hello-world.wasm 文件碰巧没有起始段
- 编码格式如下
  ```
  start_sec: 0x08|byte_count|func_idx
  ```

### 元素段
- hello-world.wasm 文件碰巧没有元素段
- 编码格式如下
  ```
  elem_sec: 0x09|byte_count|vec<elem>
      elem: table_idx|offset_expr|vec<func_idx> # 目前 table_idx 只能为 0
  ```

### 代码段
- 存放函数的字节码和方法的局部变量
- 为了节约空间，局部变量信息是压缩后存储的：连续多个相同类型的局部变量会被分为一组，统一记录变量数量和类型
- 注意：每个代码项都以该项所占字节数开头，以便于 Wasm 实现并行处理（例如，验证、分析和编译等）函数字节码
- 编码格式如下
  ```
  code_sec: 0x0A|byte_count|vec<code>
      code: byte_count|vec<locals>|expr
    locals: local_count|val_type
  ```
- 借助 xdd 可看到如下部分输出
  ```bash
  xxd -u -g 1 hello-world.wasm

  ...
  00000070: 01 0B 5F 5F 68 65 61 70 5F 62 61 73 65 03 02 0A  ..__heap_base...
                                                        --
  00000080: 7E 01 7C 00 41 C8 00 10 80 80 80 80 00 41 E5 00  ~.|.A........A..
            -----------------------------------------------
  00000090: 10 80 80 80 80 00 41 EC 00 10 80 80 80 80 00 41  ......A........A
            -----------------------------------------------
  000000a0: EC 00 10 80 80 80 80 00 41 EF 00 10 80 80 80 80  ........A.......
            -----------------------------------------------
  000000b0: 00 41 2C 10 80 80 80 80 00 41 20 10 80 80 80 80  .A,......A .....
            -----------------------------------------------
  000000c0: 00 41 D7 00 10 80 80 80 80 00 41 EF 00 10 80 80  .A........A.....
            -----------------------------------------------
  000000d0: 80 80 00 41 F2 00 10 80 80 80 80 00 41 EC 00 10  ...A........A...
            -----------------------------------------------
  000000e0: 80 80 80 80 00 41 E4 00 10 80 80 80 80 00 41 21  .....A........A!
            -----------------------------------------------
  000000f0: 10 80 80 80 80 00 41 0A 10 80 80 80 80 00 0B 00  ......A.........
            --------------------------------------------
  ...
  ```
- 借助 wasm-objdump 工具可看到如下部分解码结果
  ```bash
  wasm-objdump -x hello-world.wasm

  ...
  Code[1]:
  - func[1] size=124 <main>
  ...
  ```

### 数据段
- 数据段 vs 元素段
  - 元素段存放表初始化数据，数据段存放内存初始化数据
  - 数据项包含三部分信息：内存索引、内存偏移量、初始数据
  - 目前模块最多只能导入或定义一块内存，所以内存索引必须为 0
  - 内存偏移量也由表达式指定
- 编码格式
  ```
  data_sec: 0x0B|byte_count|vec<data>
      data: mem_idx|offset_expr|vec<byte>
  ```
- hello-world.wasm 碰巧没有数据段

### 自定义段
- 相对于其他段，自定义有两点不同
  - 自定义段不参与模块语义
  - 可以出现在任意非自定义段前后，且次数不限
- Wasm 规范要求自定义段必须以一个字符串开头，标识自定义段
- Wasm 规范在附录 7.4 定义了一个标准的自定义段，名为 `name`，专门用于存放模块名、内部函数名和局部变量名
- 编码格式如下
  ```
  custom_sec: 0x00|byte_count|name|byte*
  ```
- 借助 xdd 可看到如下部分输出
  ```bash
  xxd -u -g 1 hello-world.wasm

  ...
  000000f0: 10 80 80 80 80 00 41 0A 10 80 80 80 80 00 0B 00  ......A.........
                                                        --
  00000100: 1A 04 6E 61 6D 65 01 13 02 00 0A 70 72 69 6E 74  ..name.....print
            -----------------------------------------------
  00000110: 5F 63 68 61 72 01 04 6D 61 69 6E                 _char..main
            --------------------------------
  ```
- 借助 wasm-objdump 工具可看到如下部分解码结果
  ```bash
  wasm-objdump -x hello-world.wasm

  ...
  Custom:
  - name: "name"
  - func[0] <print_char>
  - func[1] <main>
  ```

## 二进制格式解码

### LEB 128

- LEB 128 全称为 Little Endian Base 128。
- 两个特点
  - 小端编码，低位字节在前，高位字节在后
  - 128 进制，每 7 比特一组，最高位是标识位，1 表示还有后续字节，0 表示没有
- 两种变体
  - 无符号整数
    ```
    LE-encoded: 11100101 10001110 00100110
                 -------  -------  -------
                 1        2        3
    BE-unsigned: 00001001 10000111 01100101
    ```
  - 有符号整数：最后一字节的第二高位是符号位。如果符号位为 1，表示这是个负数，高位全部补 1，否则补 0
    ```
    LE-encoded: 11000000 10111011 01111000
                -------  -------  -------
                1        2        3
    BE-signed: 11111110 00011101 11000000
    ```
  