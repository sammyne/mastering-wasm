# 06. 内存

## 介绍
- wasm 内存是一个随机存取存储器（Random Access Memory，简称 RAM），本质上是一个线性的字节数组，可以按偏移量读写任意字节
- 数值在 wasm 内存按小端存储
- wasm 内存可以在限制范围内动态增长
  - 增长必须以页为单位，每页 2^16 字节（64 KB）
  - 内存总页数不能超过 2^16，即模块能够使用的内存不能超过 4GB

## 实现
- 由于内存实际就是一个字节数组，可用 go 语言的字节切片类型来表示

## 指令
- 内存指令共 25 条，按操作可分为 3 组
  - 14 条加载指令，从内存读取数据，压入数据栈
  - 9 条存储指令，从栈顶弹出数值，写入内存
  - 2 条页数获取和增长指令，不读写内存，只获取或增长内存页数

### size 和 grow
- `memory.size`（操作码 0x3F）把内存的当前页数以 `i32` 类型压栈
  - 这条指令带有一个字节立即数，指定操作的内存索引，目前必须为 0
- `memory.grow`（操作码 0x40）将内存增长若干页，顺便获取增长前的页数
  - 执行时，该指令需要从栈顶弹出一个 `i32` 类型的数，代表要增长的页数
  - 如果增长成功，指令把增长前的页数以 `i32` 类型压栈，否则把 -1 压栈
  - 指令带有一个单字节的立即数，指定操作的内存索引，目前必须为 0

### 加载
- wasm 使用 `立即数+操作数` 的内存寻址方式
- 所有加载和存储指令都带有两个立即数：对齐方式和内存偏移量
  - 对齐方式存放的是以 2 为底，对齐字节数的对数。例如，0 表示 2^0 字节对齐
  - 对齐方式只起提示作用，目的是帮助 JIT/AOT 编译器生成更优化的机器代码，对实际执行结果没有任何影响
- 存储和加载指令还需要从操作数栈弹出一个 `i32` 类型的数，把它和立即数偏移量相加，即可得到实际内存地址
- 由于静态立即数偏移量和动态操作数偏移量都被解释为 `uint32`，所以 wasm 实际上拥有 33 比特的地址空间
- 相关指令汇总如下

  读取字节\压栈类型 | i32 | i64 | f32 | f64
  -------------|--------|-----|----|------
  8 | | i64.load | | f64.load
  4 | i32.load | i64.load32_s | f32.load |
  4 |  | i64.load32_u |  |
  2 | i32.load16_s | i64.load16_s | | 
  2 | i32.load16_u | i64.load16_u | | 
  1 | i32.load8_s | i64.load8_s | | 
  1 | i32.load8_u | i64.load8_u | | 

### 存储
- 相关指令汇总如下

  写入字节\操作数类型 | i32 | i64 | f32 | f64
  -----------------|-----|-----|-----|--------
  8 | | i64.store | | f64.store
  4 | i32.store | i64.store_32 | f32.store |
  2 | i32.store_16 | i64.store_16 | | 
  1 | i32.store_8 | i64.store_8 | |