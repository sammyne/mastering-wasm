# 11. 错误处理和验证

本章主要分为两个部分
- 整理 wasm 模块在解码、链接、初始化和函数执行等各个阶段可能出现的异常情况
- 讨论执行代码前对 wasm 模块进行静态分析，重点介绍函数字节码的验证逻辑

## 各种错误
### 解码错误
- 格式不匹配
  - 二进制数据的魔数（前 4 字节）和 wasm 规范不符
- 版本不支持
  - 二进制模块的版本号（跟在魔数后面的 4 字节）和 wasm 实现所支持的版本号不匹配
- 数据不正常
  - 所有段都以 ID 和内容字节数开头，实际内容长度不严格和描述相符的都说明数据有问题
- 段顺序错乱
  - 除了自定义段，其他段在二进制模块必须按顺序出现，且最多只能出现一次
- 枚举值错误
  - 诸如值类型、全局变量的可变性、表的元素类型、导入和导出描述的 tag 等都能为几个枚举值之一
- 变长证书解码错误
  - LEB128 编码的数据解码错误
- 字符串解码错误
  - 导入和导出项的模块名/成员名、自定义段名字等存放的必须是 UTF-8 编码后的字符串
- 函数和代码错误
  - 函数段和代码段数量必须相等
  - 解码过程遇到未定义的操作码或结构化控制指令未正常闭合说明字节码有问题
- 表达式错误
  - 元素和数据段的偏移量、全局变量的初始值由常量表达式（只能包含常量指令）指定，解密出错说明其所在段有问题

### 结构错误
- 解码阶段只检查明显的格式问题，其他错误在验证阶段检查
- 验证阶段进行两项检查
  - 确保模块整体结构良好
  - 确保函数字节码行为良好
- 段验证规则如下

    段 ID | 段 | 验证规则
    ------|----|--------
    0 | 自定义段 | 数据可完全忽略
    1 | 类型段 | 函数类型无须特别检查
    2 | 导入段 | 导入的函数索引必须有效，表只能导入一张且类型有效，内存只能导入一块且类型有效
    3 | 函数段 | 类型索引有效
    4 | 表段 | 如果已导入，则不允许定义新表，否则最多定义一张且类型有效
    5 | 内存段 | 如果已导入，则不允许定义新内存，否则最多定义一块且类型有效
    6 | 全局段 | 全局项的初始化表达式有效
    7 | 导出段 | 导出项名称唯一，且索引有效
    8 | 起始段 | 函数索引有效，且函数类型有效（无参、无返回值）
    9 | 元素段 | 元素的表索引必须为 0，偏移量表达式有效，且列出的函数索引有效
    10 | 代码段 | 代码数量和函数数量一致，且字节码有效
    11 | 数据段 | 内存索引必须为 0，偏移量表达式有效

    - 对于表和内存类型，额外要求如下
      - 如果给定上限，上限不能小于下限
      - 表和内存的上限分别不能超过 2^16 和 2^32
    - 表和内存项的偏移量、全局项的初始值均使用特殊的常量表达式指定
      - 指令只能是 4 种常量指令或 `global.get` 指令
      - 对于表和内存偏移量，表达式的结果必须是 `i32` 类型
      - 对于全局变量，表达式结果和全局变量类型一致

### 实例化错误

- 链接错误
  - 找不到模块
  - 找不到模块成员
  - 类型不匹配：函数签名不一致，表和内存限制不一致，全局变量类型或可变性不一致
- 初始化错误（初始化阶段对表、内存和全局变量进行初始化，然后执行起始函数（如果有））
  - 内存地址越界
  - 表索引越界
  - 起始函数执行错误

### 运行时错误

指令类型 | 指令 | 错误
--------|------|---------
控制 | unreachable | wasm 程序主动产生错误
控制 | call | 调用栈溢出
控制 | call_indirect | 调用栈溢出，函数类型不匹配
内存 | load/store | 内存地址越界
数值 | i32/i64.div_s | 除零错误，整数溢出
数值 | i32/i64.div_s | 除零错误
数值 | i32/i64.rem_s/u | 除零错误
数值 | i32/i64.trunc_ ... | 整数溢出，无法转换

## 验证整体结构
这一节主要是代码实现，详情参见随书代码即可。

## 验证函数字节码

验证过程的两项检查
- 指令立即数
  - 例如，变量指令带有变量索引
  - 跳转指令带有目标标签索引，必须通过一个模拟的操作数栈才能进行验证，且要考虑跳转目标的控制帧类型
- 操作数栈状态
  - 确保指令执行前，操作数栈顶有期望数量和类型的操作数
